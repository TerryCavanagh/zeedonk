Game.title = "Fancy Roguelike Example";

// ASSETS START HERE
Gfx.loadimagestring("icon0", "3SaaapZZZSaZCcYJFcQHa"); // Corner, Top left
Gfx.loadimagestring("icon1", "3SaaapZZZSbZaxPXdwOHa"); // Corner, Top right
Gfx.loadimagestring("icon2", "3SaaapZZZUOHFcYJCdYaa"); // Corner, Bottom left
Gfx.loadimagestring("icon3", "3SaaapZZZUPHdxPXaxWaa"); // Corner, Bottom right
Gfx.loadimagestring("icon4", "3SaaapZZZSbZ6hZZ9gQHa"); // Up
Gfx.loadimagestring("icon5", "3SaaapZZZUPH9hZZ6hYaa"); // Down
Gfx.loadimagestring("icon6", "3SaaapZZZUOHFcYJFcQHa"); // Left
Gfx.loadimagestring("icon7", "3SaaapZZZUPHdxPXdwOHa"); // Right
Gfx.loadimagestring("icon8", "3SaaapZZZSbZ6hZZ6hYaa"); // Horizontal
Gfx.loadimagestring("icon9", "3SaaapZZZUOHlsOHlsOHa"); // Vertical
Gfx.loadimagestring("icon10", "3SaaapZZZUPH9hZZ9gQHa"); // Cross
Gfx.loadimagestring("icon11", "3SaaapZZZYRNCuNmCxpH6"); // Mine
Gfx.loadimagestring("icon12", "3SaaapZZZZZaKmdaKmdZ6"); // Square
Gfx.loadimagestring("icon13", "3SaaapZZZSa4mMOHmLSaa"); // Radio button, selected
Gfx.loadimagestring("icon14", "3SaaapZZZSa4mMe7mLSaa"); // Radio button, unselected
Gfx.loadimagestring("icon15", "3SaaapZZZS2hbaqWpdKSa"); // Music Note
Gfx.loadimagestring("icon16", "3SaaapZZZSK4pRY4h7Saa"); // Up arrow
Gfx.loadimagestring("icon17", "3SaaapZZZSa4h7TZJLSma"); // Down arrow
Gfx.loadimagestring("icon18", "3SaaapZZZS6ypRXZpL6ia"); // Left arrow
Gfx.loadimagestring("icon19", "3SaaapZZZSqgpNYZJKyea"); // Right arrow
Gfx.loadimagestring("icon20", "3SaaapZZZVnZZZZZJLSma"); // Heart
Gfx.loadimagestring("icon21", "3SaaapZZZSK4pRZZJLSma"); // Diamond
Gfx.loadimagestring("icon22", "3SaaapZZZSK4pRZZJKK4a"); // Spade
Gfx.loadimagestring("icon23", "3SaaapZZZSK4hARZZYQma"); // Club
Gfx.loadimagestring("icon24", "3SaaapZZZWqaaabeaaaaa"); // Dither, 1
Gfx.loadimagestring("icon25", "3SaaapZZZWqaeqbeabeaa"); // Dither, 2
Gfx.loadimagestring("icon26", "3SaaapZZZXuaeqbvabeaa"); // Dither, 3
Gfx.loadimagestring("icon27", "3SaaapZZZXuavqbvafuaa"); // Dither, 4
Gfx.loadimagestring("icon28", "3SaaapZZZXu8vqbvi=uaa"); // Dither, 5
Gfx.loadimagestring("icon29", "3SaaapZZZXu8vq9vi=ui6"); // Dither, 6
Gfx.loadimagestring("icon30", "3SaaapZZZXuEPq9vkHui6"); // Dither, 7
Gfx.loadimagestring("icon31", "3SaaapZZZXuEPsFvkHuE6"); // Dither, 8
Gfx.loadimagestring("icon32", "3SaaapZZZZ2EPsFRkHuE6"); // Dither, 9
Gfx.loadimagestring("icon33", "3SaaapZZZZ2ER0FRkHQE6"); // Dither, 10
Gfx.loadimagestring("icon34", "3SaaapZZZZYER0FZEHQE6"); // Dither, 11
Gfx.loadimagestring("icon35", "3SaaapZZZZYEZUFZEJYE6"); // Dither, 12
Gfx.loadimagestring("icon36", "3SaaapZZZZZIZUFZVJYE6"); // Dither, 13
Gfx.loadimagestring("icon37", "3SaaapZZZZZIZVJZVJYV6"); // Dither, 14
Gfx.loadimagestring("icon38", "3SaaapZZZZZZZVJZZZYV6"); // Dither, 15
Gfx.loadimagestring("icon39", "3KaaapZZZZaRL5aRL0EEEEEEEEEEEEEEEEEEEEE"); // Full
Gfx.loadimagestring("icon40", "3SaaapZZZVXZV5Z7WZYZa"); // Face, filled
Gfx.loadimagestring("icon41", "3SaaapZZZVXaOGd4NmcZa"); // Face, outlined
Gfx.loadimagestring("icon42", "3SaaapZZZVWZadWZadWZa"); // Three, Horizontal
Gfx.loadimagestring("icon43", "3SaaapZZZSbHV4RHV4Qaa"); // Three, Vertical
Gfx.loadimagestring("icon44", "3SaaapZZZSaZpKaapNWaa"); // Two, Horizontal
Gfx.loadimagestring("icon45", "3SaaapZZZSaNmNmNmNmaa"); // Two, Vertical
Gfx.loadimagestring("icon46", "3SaaapZZZSaaadWZaaaaa"); // One, Horizontal
Gfx.loadimagestring("icon47", "3SaaapZZZSamdaKmdaKaa"); // One, Vertical
Gfx.loadimagestring("icon48", "3SaaapZZZSgd7KT24dbya"); // Sword
Gfx.loadimagestring("icon49", "3SaaapZZZZZaRGNmS1m4a"); // Shield
Gfx.loadimagestring("icon50", "3SaaapZZZS2n6yogdb6Ka"); // Staff
Gfx.loadimagestring("icon51", "3SaaapZZZSSsiBY8i7ioa"); // Bow
Gfx.loadimagestring("icon52", "3SaaapZZZSahbK2hhNWaa"); // Boots
Gfx.loadimagestring("icon53", "3SaaapZZZSnB59ithVAKa"); // Throwing star
Gfx.loadimagestring("icon54", "3SaaapZZZSa7ltWZitWaa"); // Helmet
Gfx.loadimagestring("icon55", "3SaaapZZZSbNZZYNh9Waa"); // Armor
Gfx.loadimagestring("icon56", "3SaaapZZZSaZpNmNmNmaa"); // Trousers
Gfx.loadimagestring("icon57", "3SaaapZZZTSLjkEEEk26a"); // Whip
Gfx.loadimagestring("icon58", "3SaaapZZZWd7ZZZHNiKma"); // Axe
Gfx.loadimagestring("icon59", "3SaaapZZZSaZpNWmdaKaa"); // Hammer
Gfx.loadimagestring("icon60", "3SaaapZZZSaahsi8i7Oaa"); // Alpha
Gfx.loadimagestring("icon61", "3SaaapZZZTK8i9K8isSaa"); // Beta
Gfx.loadimagestring("icon62", "3SaaapZZZSaaJPise7iaa"); // Pi
Gfx.loadimagestring("icon63", "3SaaapZZZVWLgaKymtWaa"); // Sigma
Gfx.loadimagestring("icon64", "3SaaapZZZSaahMi8i7Kaa"); // Sigma, lower
Gfx.loadimagestring("icon65", "3SaaapZZZSa4ise7e9maa"); // Omega
Gfx.loadimagestring("icon66", "3SaaapZZZTSNitWZitm4a"); // Theta
Gfx.loadimagestring("icon67", "3SaaapZZZUeHlsOZh6Kma"); // Psi
Gfx.loadimagestring("icon68", "3SaaapZZZSK4lsOHlrSma"); // Phi
Gfx.loadimagestring("icon69", "3SaaapZZZTWKgaStitm4a"); // Delta
Gfx.loadimagestring("icon70", "3SaaapZZZSaKwaKogNgaa"); // Lambda
Gfx.loadimagestring("icon71", "3SaaapZZZSaNmNmNoNyKa"); // Mu
Gfx.loadimagestring("icon72", "3SaaapZZZSK4f7isg7Sma"); // Crystal 1
Gfx.loadimagestring("icon73", "3SaaapZZZS62nA2TAKSea"); // Crystal 2
Gfx.loadimagestring("icon74", "3SaaapZZZSK7dfls9cema"); // Crystal 3
Gfx.loadimagestring("icon75", "3SaaapZZZSasddmNdbiaa"); // Crystal 4
Gfx.loadimagestring("icon76", "3SaaapZZZSa4nNOJoLSaa"); // Crystal 5
Gfx.loadimagestring("icon77", "3SaaapZZZSy44QmLHTSya"); // Crystal 6
Gfx.loadimagestring("icon78", "3SaaapZZZTSNmLSehaq2a"); // Key 1
Gfx.loadimagestring("icon79", "3SaaapZZZUeZpLSehaq2a"); // Key 2
Gfx.loadimagestring("icon80", "3SaaapZZZTSNise7jse7a"); // Door 1
Gfx.loadimagestring("icon81", "3SaaapZZZTSZpNWZptWZa"); // Door 2
Gfx.loadimagestring("icon82", "3SaaapZZZSa4pKaZmNWaa"); // Chest
Gfx.loadimagestring("icon83", "3SaaapZZZSa4h7SmdaKaa"); // Lock
Gfx.loadimagestring("icon84", "3SaaapZZZSacaKqimbaaa"); // Bone
Gfx.loadimagestring("icon85", "3SaaapZZZSa4pMGFp7Kaa"); // Skull
Gfx.loadimagestring("icon86", "3SaaapZZZYhNZXVmZYR76"); // Monster
Gfx.loadimagestring("icon87", "3SaaapZZZSa4pMOZmPkHa"); // Monster 2
Gfx.loadimagestring("icon88", "3SaaapZZZTSZltWZpNWHa"); // Ghost
Gfx.loadimagestring("icon89", "3SaaapZZZSa4daK4pNW4a"); // Potion
Gfx.loadimagestring("icon90", "3SaaapZZZTS7ls$=lse4a"); // S Token
Gfx.loadimagestring("icon91", "3SaaapZZZTSZ5ZZZZVW4a"); // Circle
Gfx.loadimagestring("icon92", "3SaaapZZZSKmh7SZpRZZ6"); // Triangle
Gfx.loadimagestring("icon93", "3SaaapZZZZZaRHlsQGlY6"); // Spiral
Gfx.loadimagestring("icon94", "3SaaapZZZSbZjtWDpMeZ6"); // Scroll
Gfx.loadimagestring("icon95", "3SaaapZZZSa4iuNmCrSaa"); // Eye
Gfx.loadimagestring("icon96", "3SaaapZZZX3xvvvRvfrua"); // HP
Gfx.loadimagestring("icon97", "3SaaapZZZZ3RruvRfhrOa"); // SP
Gfx.loadimagestring("icon98", "3SaaapZZZScb6W3I5d6qa"); // Tick
Gfx.loadimagestring("icon99", "3SaaapZZZVgVBKS5oVgaa"); // X
Gfx.loadimagestring("icon100", "3SaaapZZZZZaRHV4RGdZ6"); // Block 1
Gfx.loadimagestring("icon101", "3SaaapZZZZZ7NnlsNohZ6"); // Block 2
Gfx.loadimagestring("icon102", "3SaaapZZZXuaR7lshGaE6"); // Block 3
Gfx.loadimagestring("icon103", "3SaaapZZZSb5RXYa4ZJV6"); // Block 4
Gfx.loadimagestring("icon104", "3SaaapZZZSbgRXYem5JV6"); // Block 5
Gfx.loadimagestring("icon105", "3SaaapZZZSa6aaeaabaaa"); // Ground 1
Gfx.loadimagestring("icon106", "3SaaapZZZSaSaaad6haaa"); // Ground 2
Gfx.loadimagestring("icon107", "3SaaapZZZSKZiwh7CtWma"); // Target
Gfx.loadimagestring("icon108", "3SaaapZZZSacdyaaegKaa"); // Water
Gfx.loadimagestring("icon109", "3SaaapZZZVXZV5ZNS5YZa"); // Sad face, filled
Gfx.loadimagestring("icon110", "3SaaapZZZVXaOGdmRGcZa"); // Sad face, outlined
Gfx.loadimagestring("icon111", "3SaaapZZZZYa5SbZ6hYaa"); // Grate

var icon = [];
for(i in 0 ... 112) icon.push("icon"+i);
// ASSETS END HERE

var currentmap;
var lightmap;

var playerx;
var playery;

var mapwidth;
var mapheight;

var playertile;
var floortile;
var walltile;
var scrolltile;
var potiontile;
var doortile;

var steppedon;
var oldtile;

var redrawmap;
var newtile;

var iconcolor = [];

var uselighting = 1;

var message = "SIMPLE ROGUELIKE EXAMPLE - PRESS ARROW KEYS TO MOVE";
var messagecol = Col.GRAY;

var shaketiles = [];
var numshaketiles = 0;

var rooms = [];
var numrooms = 0;

var tx;
var ty;
var tw;
var th;

function new(){
  Gfx.showfps=true;
  Text.setfont(Font.THIN);
  Gfx.clearscreeneachframe=false;
  currentmap = [];
  lightmap = [];
  
  playerx = 20;
  playery = 9;
  
  mapwidth = 30;
  mapheight = 17;
  
  //These numbers corespond to the icons we want to use from the asset pack
  playertile = 93;
  floortile = 105;
  walltile = 103;
  scrolltile = 94;
  potiontile = 89;
  doortile = 81;
  opendoortile = 80;
  
  steppedon = floortile;
  
  for(i in 0 ... 100){
    shaketiles.push({x:0, y:0, xoff:0, yoff:0, shake:0});
    rooms.push({x:0, y:0, w:0, h:0, type:0});
  }
  numshaketiles = 0;
  numrooms = 0;
    
  for(i in 0 ... mapwidth) {
    currentmap.push([]);
    lightmap.push([]);
    for(j in 0 ... mapheight){
      currentmap[i].push(-1);
      lightmap[i].push(0);
    }
  }
  redrawmap = true;
  
  for(i in 0 ... 140) iconcolor.push(Col.RED);
  iconcolor[playertile] = Col.WHITE;
  iconcolor[floortile] = Col.NIGHTBLUE;
  iconcolor[walltile] = 0x7070e5;
  iconcolor[scrolltile] = Col.WHITE;
  iconcolor[potiontile] = Col.MAGENTA;
  iconcolor[doortile] = Col.BROWN;
  iconcolor[opendoortile] = Col.DARKBROWN;
  
  generate(0);
  playerx = Random.int(1,mapwidth-2);
  playery = Random.int(1,mapheight-2);
  while(currentmap[playerx][playery] != floortile){
    playerx = Random.int(1,mapwidth-2);
    playery = Random.int(1,mapheight-2);
  }
  currentmap[playerx][playery]=playertile;
  
}

function addroom(x, y, w, h, type){
  rooms[numrooms].x = x;
  rooms[numrooms].y = y;
  rooms[numrooms].w = w;
  rooms[numrooms].h = h;
  rooms[numrooms].type = type;
  
  numrooms++;
}

function inbox(xp, yp, x, y, w, h){
  if(xp >= x){
    if(yp >= y){
      if(xp < x + w){
        if(yp < y + h){
          return true;
        }
      }
    }
  }
  return false;
}

function checkroomcollision(){
  for(i in 0 ... numrooms){
    if(inbox(tx, ty, rooms[i].x-1, rooms[i].y-1, rooms[i].w+2, rooms[i].h+2)) return true;
    if(inbox(tx + tw, ty, rooms[i].x-1, rooms[i].y-1, rooms[i].w+2, rooms[i].h+2)) return true;
    if(inbox(tx, ty + th, rooms[i].x-1, rooms[i].y-1, rooms[i].w+2, rooms[i].h+2)) return true;
    if(inbox(tx + tw, ty + th, rooms[i].x-1, rooms[i].y-1, rooms[i].w+2, rooms[i].h+2)) return true;
  }
  return false;
}

function generate(type){
  var roomsleft = 0;
  var roomscreated = 0;
  
	if(type == 0){
  	//Basic room type
    //Generate between 5 - 10 non intersecting rooms
    while (roomsleft == 0 && roomscreated < 7){
      trace("generating room...");
      roomsleft = 10;
      roomscreated = 0;
      numrooms = 0;

      while(roomsleft > 0){
        //Random room coordinates
        tw = Random.int(2,6);
        th = Random.int(2,5);
        tx = Random.int(1, mapwidth-2-tw);
        ty = Random.int(1, mapheight-2-th);

        //Ok, Check if this collides with any existing rooms
        if(checkroomcollision()){
          roomsleft--;
        }else{
          roomscreated++;
          roomsleft--;
          addroom(tx, ty, tw, th, 0);
        }
      }
    }
    
    //Now find the bounds of the map, so we can center it a bit
    tx = mapwidth; ty = mapheight;
    tw = 0; th = 0; 
    for(i in 0 ... numrooms){
      if(rooms[i].x < tx) tx = rooms[i].x;
      if(rooms[i].y < ty) ty = rooms[i].y;
      if(rooms[i].x + rooms[i].w > tw) tw = rooms[i].x + rooms[i].w;
      if(rooms[i].y + rooms[i].h > th) th = rooms[i].y + rooms[i].h;
    }
    
    tx = Convert.toint((tx + mapwidth - tw)/2) - tx;
    ty = Convert.toint((ty + mapheight - th)/2) - ty;
    //Ok, now we nudge the rooms around before finally drawing them:
    for(i in 0 ... numrooms){
      rooms[i].x += tx;
      rooms[i].y += ty;
      drawroom(rooms[i].x, rooms[i].y, rooms[i].w, rooms[i].h);
    }
    
    //Ok! Now we connect the rooms with passageways.
    for(i in 0 ... numrooms - 1){
      tx = Random.int(rooms[i].x + 1, rooms[i].x + rooms[i].w - 2);
      ty = Random.int(rooms[i].y + 1, rooms[i].y + rooms[i].h - 2);
      tw = Random.int(rooms[i + 1].x + 1, rooms[i + 1].x + rooms[i + 1].w - 2);
      th = Random.int(rooms[i + 1].y + 1, rooms[i + 1].y + rooms[i + 1].h - 2);
      
      if(tx > tw){
        drawhline(tw, th, tx - tw + 1); 
        if(ty > th){
          drawvline(tx, th, ty - th + 1);
        }else{
          drawvline(tx, ty, th - ty + 1);
        }
      }else{
        drawhline(tx, ty, tw - tx + 1);
        if(ty > th){
          drawvline(tw, th, ty - th + 1);
        }else{
          drawvline(tw, ty, th - ty + 1);
        }
      }
    }
    
    //Ok! Let's place some stuff in this room. 
    //Walls
    addwalllayer();
    //Doors:
    adddoorlayer();
    //Entrance:
    //Exit:
  }  
  trace("generated!");
}

function shake(x, y, xoff, yoff){
  if(numshaketiles<100){
    shaketiles[numshaketiles].x = x;
    shaketiles[numshaketiles].y = y;
    shaketiles[numshaketiles].xoff = xoff;
    shaketiles[numshaketiles].yoff = yoff;
    shaketiles[numshaketiles].shake = 5;
    numshaketiles++;
  }
}

function processshake(){
  for(i in 0 ... numshaketiles){
    if(shaketiles[i].shake>0){
      shaketiles[i].shake--;
      var x=shaketiles[i].x;
      var y=shaketiles[i].y;
      var xoff=shaketiles[i].shake * shaketiles[i].xoff;
      var yoff=shaketiles[i].shake * shaketiles[i].yoff;
      if(shaketiles[i].shake==0){
        xoff = 0; yoff = 0;
      }
      var t = currentmap[x][y];
      Gfx.fillbox((x * 8), (y * 8), 8, 8, Col.BLACK);
      pset(x-1,y-1);
      pset(x,y-1);
      pset(x+1,y-1);
      pset(x-1,y);
      pset(x+1,y);
      pset(x-1,y+1);
      pset(x,y+1);
      pset(x+1,y+1);

      if(t > -1) {
        Gfx.imagecolor(iconcolor[t]);
        Gfx.drawimage((x * 8) + xoff, (y * 8) + yoff, icon[t]);
      }
    }
  }
  
  if(numshaketiles > 0){
    if(shaketiles[numshaketiles-1].shake==0){
      numshaketiles--;
    }
  }
}

function drawroom(x, y, w, h){
  for(j in y ... y + h){
    for(i in x ... x + w){
      currentmap[i][j] = floortile;
    }
  }
}

function drawhline(x1, y, w){
  for(i in x1 ... x1 + w){
    currentmap[i][y] = floortile;
  }
}


function drawvline(x1, y1, h){
  for(i in y1 ... y1 + h){
    currentmap[x1][i] = floortile;
  }
}

function adddoorlayer(){
  for(k in 0 ... numrooms){
    for(j in rooms[k].y - 1 ... rooms[k].y + rooms[k].h + 1) {
      //Left edge!
      if(pget(rooms[k].x - 1, j) == floortile){
        if(pget(rooms[k].x - 1, j - 1) != floortile && 
           pget(rooms[k].x - 1, j + 1) != floortile){
          currentmap[rooms[k].x - 1][j] = doortile;
        }
      } 
      //Right edge!
      if(pget(rooms[k].x + rooms[k].w, j) == floortile){
        if(pget(rooms[k].x + rooms[k].w, j - 1) != floortile && 
           pget(rooms[k].x + rooms[k].w, j + 1) != floortile){
          currentmap[rooms[k].x + rooms[k].w][j] = doortile;
        }
      } 
    }
    
    for(i in rooms[k].x - 1 ... rooms[k].x + rooms[k].w + 1){
    	//Top edge!
      if(pget(i, rooms[k].y - 1) == floortile){
        if(pget(i - 1, rooms[k].y - 1) != floortile && 
           pget(i + 1, rooms[k].y - 1) != floortile){
          currentmap[i][rooms[k].y - 1] = doortile;
        }
      }
      //Bottom edge!
      if(pget(i, rooms[k].y + rooms[k].h) == floortile){
        if(pget(i - 1, rooms[k].y + rooms[k].h) != floortile && 
           pget(i + 1, rooms[k].y + rooms[k].h) != floortile){
          currentmap[i][rooms[k].y + rooms[k].h] = doortile;
        }
      }
    }
  }
}

function addwalllayer(){
  for(j in 0 ... mapheight){
    for(i in 0 ... mapwidth){
      if(currentmap[i][j] == -1){
        if(pget(i-1,j) == floortile) currentmap[i][j] = walltile;
        if(pget(i+1,j) == floortile) currentmap[i][j] = walltile;
        if(pget(i,j-1) == floortile) currentmap[i][j] = walltile;
        if(pget(i,j+1) == floortile) currentmap[i][j] = walltile;
        if(pget(i-1,j-1) == floortile) currentmap[i][j] = walltile;
        if(pget(i+1,j-1) == floortile) currentmap[i][j] = walltile;
        if(pget(i-1,j+1) == floortile) currentmap[i][j] = walltile;
        if(pget(i+1,j+1) == floortile) currentmap[i][j] = walltile;
      }
    }
  }
  /*
  for(j in 0 ... mapheight){
    for(i in 0 ... mapwidth){
      if(currentmap[i][j] == floortile){      
        tx = 0;
        if(pget(i-1,j) == floortile) tx++;
        if(pget(i+1,j) == floortile) tx++;
        if(pget(i,j-1) == floortile) tx++; 
        if(pget(i,j+1) == floortile) tx++; 
        if(pget(i-1,j-1) == floortile) tx++;
        if(pget(i+1,j-1) == floortile) tx++;
        if(pget(i-1,j+1) == floortile) tx++;
        if(pget(i+1,j+1) == floortile) tx++;
        
        if(tx == 4){
          if(pget(i-1,j) != floortile && pget(i+1,j) != floortile){
            currentmap[i][j] = doortile;
          }else if(pget(i,j-1) != floortile && pget(i,j+1) != floortile){
            currentmap[i][j] = doortile;
          }
        } 
      }
    }
  }
*/
}

function setlight(x, y, t){
  if(uselighting > 0){
    if(x>=0 && y>=0){
      if(x < mapwidth && y < mapheight){
        if(lightmap[x][y]<=t){
          lightmap[x][y]=t;

          if(t >= 3){
            pset(x,y,currentmap[x][y]);
          }else if(t == 2){
            Gfx.fillbox(x * 8, y * 8, 8, 8, Col.BLACK);
            Gfx.imagecolor(Col.GRAY);
            Gfx.drawimage(x*8, y*8, icon[25]);
          }else if(t == 1){
            Gfx.fillbox(x * 8, y * 8, 8, 8, Col.BLACK);
            Gfx.imagecolor(Col.GRAY);
            Gfx.drawimage(x*8, y*8, icon[28]);
          }else if(t == 0){
            Gfx.fillbox(x * 8, y * 8, 8, 8, Col.BLACK);
            Gfx.imagecolor(Col.GRAY);
            Gfx.drawimage(x*8, y*8, icon[31]);
          }
        }
      }
    }
  }
}

function flashlight(x, y, xoff, yoff){
  x+=xoff;
  y+=yoff;
  tx = pget(x, y);
  if(tx == floortile){
    for(j in -1 ... 2){
      for(i in -1 ... 2){
        setlight(x + i, y + j, 3);
      }
    }
    flashlight(x, y, xoff, yoff);
  }
}

function light(x, y){
  if(uselighting == 1){
    
    for(j in -5 ... 6){
      for(i in -5 ... 6){
        setlight(x + i, y + j, 5-Convert.toint(Math.sqrt(i*i + j*j)));
      }
    }
    
    flashlight(x, y, -1, 0);
    flashlight(x, y, 1, 0);
    flashlight(x, y, 0, -1);
    flashlight(x, y, 0, 1);
  }
}

function pset(x, y, ?t, ?color){
  //Instead of redrawing the entire screen each time, we just
  //draw what's actually changed.
  if(x>=0 && y>=0){
    if(x < mapwidth && y < mapheight){
      //Update the map for reference
      if(t == null){
        t=currentmap[x][y];
      }else{
        currentmap[x][y]=t;  
      }
      
      //Change the character
      Gfx.fillbox(x * 8, y * 8, 8, 8, Col.BLACK);
      if(t > -1) {
        if(color == null) color = iconcolor[t];
        Gfx.imagecolor(color);
        Gfx.drawimage(x*8, y*8, icon[t]);
      }
    }
  }
}

function pget(x, y){
  if(x>=0 && y>=0){
    if(x < mapwidth && y < mapheight){
      return currentmap[x][y];
    }
  }
  return -1;
}

function moveplayer(xoff, yoff){
  pset(playerx, playery, steppedon);
  
  //Check new position for interaction
  oldtile = steppedon;
  newtile = pget((playerx + mapwidth + xoff) % mapwidth, (playery + mapheight + yoff) % mapheight);
  steppedon = newtile;
  if(newtile == walltile){
    //Wall, play a bump sound
    Music.playsound(68417307);
    //Prevent the player from moving
    shake((playerx + mapwidth + xoff) % mapwidth, 
          (playery + mapheight + yoff) % mapheight,
         xoff, yoff);
    xoff = 0; yoff = 0;
  }else if(newtile == opendoortile){
    steppedon = opendoortile;
  }else if(newtile == doortile){
    //Remove the door, drop and open door, play a sound
    Music.playsound(32259507);
    steppedon = opendoortile;
  }else if(newtile == potiontile){
    //Remove the potion, play a sound
    Music.playsound(72329307);
  }else if(newtile == scrolltile){
    //Scroll, play a collect sound and change the message
    Music.playsound(84140903);
    message = "SEE *** FOR A MORE COMPLEX ROGUELIKE EXAMPLE";
    messagecol = Col.YELLOW;
  }
  
  if(xoff == 0 && yoff == 0){
    steppedon = oldtile;
  }
  
  playerx = (playerx + mapwidth + xoff) % mapwidth; playery = (playery + mapheight + yoff) % mapheight;
  
  pset(playerx, playery, playertile);
  light(playerx, playery);
}

function update(){
  input();
  logic();
  render();
}


var press_left;
var press_right;
var press_up;
var press_down;
var keydelay = 0;
var keypriority = 0;
function input(){
  //Doing a keypriority thing to make input feel nicer. The basic idea is that
  //you keep moving in the last direction your pressed - most recent direction
  //gets priority.
  press_left = Input.pressed(Key.LEFT);
  press_right = Input.pressed(Key.RIGHT);
  press_up = Input.pressed(Key.UP);
  press_down = Input.pressed(Key.DOWN);
  
  if (press_left || press_right) {
    if (press_up || press_down) {
      //Both horizontal and vertical are being pressed: one must take priority
      if (keypriority == 1) { keypriority = 4;
      }else if (keypriority == 2) { keypriority = 3;
      }else if (keypriority == 0) { keypriority = 3;                                                     }
    }else {keypriority = 1;}
  }else if (press_up || press_down) {keypriority = 2;}else {keypriority = 0;}

  if (keypriority == 3) {press_up = false; press_down = false;
  }else if (keypriority == 4) { press_left = false; press_right = false; }
  
  if(keydelay>0){
    keydelay--;
    if(!(press_left || press_right || press_up || press_down)) keydelay=0;
  }else{
    if(press_left){
      moveplayer(-1, 0);
      keydelay=2;
    }else if(press_right){
      moveplayer(1, 0);
      keydelay=2;
    }
    
    if(press_up){
      moveplayer(0, -1);
      keydelay=2;
    }else if(press_down){
      moveplayer(0, 1);
      keydelay=2;
    }
  }
}

function logic(){
  
}

function render(){
  if(redrawmap){
    //Redraw the entire map. For when loads of stuff changes at once.
    redrawmap=false; 
    light(playerx, playery);
    for(j in 0 ... mapheight){
      for(i in 0 ... mapwidth){
        pset(i, j, currentmap[i][j]);
        setlight(i, j, lightmap[i][j]);
      }
    }
  }
  
  processshake();
  
  Gfx.fillbox(Gfx.screenwidth-35,0,35,7,Col.DARKBLUE);
  //Show message
  Gfx.fillbox(0, mapheight * 8, Gfx.screenwidth, 16, Col.BLACK);
  Text.display(Text.CENTER, 4 + mapheight * 8, message, messagecol);
}